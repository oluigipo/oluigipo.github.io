<!DOCTYPE html>
<!-- I'm not hiring if that's what you are looking for. -->

<head>
	<title>Plans for my "please" "game engine"</title>
	<meta charset="UTF-8"/>
	<link rel="shortcut icon" type="image/png" href="/favicon.ico">
	<link rel="stylesheet" href="/index.css">
	<style>
		
	</style>
</head>
<body>
	<div class="column">
		<p><a href="/blog">&lt; Back</a></p>
<h1>Basic overview</h1><p>I began "please" mid-2021 to learn about gamepad inputs from scratch in Windows. It was a great experiment, and got to learn a lot of DirectInput and XInput to support all kinds of gamepads out there with the help of <a href="https://github.com/gabomdq/SDL_GameControllerDB">SDL_GameControllerDB</a>. And to help visualize if the input conversion was done right, I had also programmed a simple OpenGL renderer for colored rectangles, and that was about it. </p><p>But then, I also ended up doing a bit of sound, some 3D graphics programming (lighting, shadows, normal mapping, all that stuff). At the end, it really seemed like something I could build any game I wanted with it. Sure I've only made 2D games in the past (TODO: blog entry), but the idea still seemed great. Having my own set of tools for doing my own series of work and controlling every step of the pipeline...! </p><h1>Nowadays</h1><p>I dreamed too high, I confess. Fortunately this is such a common situation for engine developers enthusiasts that I don't feel bad about it, just a bit silly. But then, if I want to work on this, what should I aim for? </p><p>Before the coaching section comes in, I want to talk a bit about how I ended up <i>removing</i> more stuff than adding into "please" during this 1.5 year period. </p><h1>Simplicity</h1><p>Fortunately I seeked a lot of it. Probably must have saved me from a weird timeline where I wrote my own 3D file format, ECS implementation, and all kinds of unecessary features. At the end, I only have a few systems in it worth talking about: </p><ul><li>The <code class="inlinecode">Engine_</code> namespace, common code for all platforms: rendering, audio mixing... and that's it?</li><li>The <code class="inlinecode">Platform_</code> namespace, platform-specific code: windowing, input translating, gamepad translating (probably should go to the <code class="inlinecode">Engine_</code> namespace?), input/output, virtual memory, etc.;</li><li>The <code class="inlinecode">Game_Main</code>: this is a function called by the <code class="inlinecode">Engine_</code> layer in a loop. You don't even need to return from it and just have your game loop in there;</li><li>The <code class="inlinecode">Pls*_</code> namespaces, common systems for games: the idea was to implement these on-demand, which is a really great idea and I will explain in a moment why.</li></ul><p>Surely, this is more than enough to start making games, but I'm still not happy with some stuff, mainly with the audio API and rendering API. </p><p>The audio API consists of just three functions in the engine namespace: <code class="inlinecode">Engine_LoadSoundBuffer(path, *out_sound)</code>, <code class="inlinecode">Engine_FreeSoundBuffer(sound)</code>, and mainly <code class="inlinecode">Engine_PlayAudios(*audios, *inout_count, volume)</code>. The biggest problem with it really is that I extract <i>all</i> audio data on load (unecessary memory consumption) and do mixing in the same thread as the game thread. Do you remember when games developed on Valve's Source Engine started loading while a sound was playing and the sound kept looping until it was done loading? "please" have the same problem. It happens due to the fact that my audio-specific thread only does a single thing: send bytes from a global buffer to WASAPI (Windows audio API I chose) when woken up by it's event. The mixing is done at the end of the frame in the main thread and then the global buffer is "swapped" and it's offset is set to 0. That's essentially double-buffering. What I want to do instead is to decode and mix the audios on-demand in the audio thread. This is surely an exercise for another day (procrastination kicks in). </p><p>The rendering API went downhill (as in 'featurelessness') since I've been redesigning it from scratch recently. Essentially just simplifying it, though it started looking like <a href="https://github.com/floooh/sokol#sokol_gfxh">sokol_gfx</a> at the lower level, but still doing some high-level work, like text rendering. Maybe I should just use sokol and just not care! I've used it a bit recently and got pretty far by just reading it's API and reading the OpenGL implementation to understand what each option really did. It's a really great abstraction, for sure. </p><h1>Okay, but what is the point now?</h1><p>Now comes what I'll try to aim for with this project from now on: learning. It just sounds like an excuse really, but that's not all. I plan to begin developing really small games with it and develop the engine itself as I go with it. That's probably the best advice one can give: make a game, not an engine. I'm surely not doing it now, so there's still more I need to work on myself about that, but that's it in general. </p><p>I've read <a href="https://medium.com/geekculture/how-to-make-your-own-game-engine-and-why-ddf0acbc5f3">this article</a> from Tyler Glaiel some years ago and it got to me again recently. Reading it again felt like a whole new thing I missed, that I could be far from where I'm now, but it doesn't bother me all that much. Now i'll try to do it better. It's a really great article btw! You should definitely read it! </p><p>That's all I had to say for now. Happy Christmas and Happy New Year! </p>
	</div>
</body>
